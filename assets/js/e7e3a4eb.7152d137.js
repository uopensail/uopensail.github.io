"use strict";(self.webpackChunkuopensail_github_io=self.webpackChunkuopensail_github_io||[]).push([[2473],{1519:e=>{e.exports=JSON.parse('{"permalink":"/blog/AppS/FM","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/AppS/FM.md","source":"@site/blog/AppS/FM.md","title":"Application of Factorization Machines (FM) Model in Application Store (AppS)","description":"Introduction","date":"2025-03-21T13:33:17.000Z","tags":[],"readingTime":4.62,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Application of the ESMM Model in AppS","permalink":"/blog/AppS/ESMM"},"nextItem":{"title":"Application of the MMOE Model in AppS","permalink":"/blog/AppS/MMOE"}}')},4068:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var t=n(1519),a=n(4848),s=n(8453);const r={},o="Application of Factorization Machines (FM) Model in Application Store (AppS)",l={authorsImageUrls:[]},c=[{value:"Introduction",id:"introduction",level:2},{value:"1. Advantages of FM over Linear Regression (LR)",id:"1-advantages-of-fm-over-linear-regression-lr",level:3},{value:"2. Time Complexity Analysis of FM",id:"2-time-complexity-analysis-of-fm",level:3},{value:"3. Ease of Engineering Implementation",id:"3-ease-of-engineering-implementation",level:3},{value:"Developing and Training FM Model with PyTorch",id:"developing-and-training-fm-model-with-pytorch",level:3},{value:"Application",id:"application",level:2},{value:"1. Feature Embedding Configuration",id:"1-feature-embedding-configuration",level:3},{value:"2. Addressing Sample Imbalance Issues",id:"2-addressing-sample-imbalance-issues",level:3},{value:"3. Data Issues and Model Optimization",id:"3-data-issues-and-model-optimization",level:3},{value:"4. AB Testing Results",id:"4-ab-testing-results",level:3},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const i={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(i.p,{children:"Factorization Machines (FM) are powerful machine learning models, especially widely used in recommendation systems and advertising click-through rate prediction. FM models can effectively capture the cross information between features and are highly efficient and easy to implement in engineering."}),"\n",(0,a.jsx)(i.img,{title:"",src:"../static/images/FM.jpg",alt:"",width:"522","data-align":"center"}),"\n",(0,a.jsx)(i.h3,{id:"1-advantages-of-fm-over-linear-regression-lr",children:"1. Advantages of FM over Linear Regression (LR)"}),"\n",(0,a.jsx)(i.p,{children:"Linear Regression (LR) is a simple and intuitive model, but it cannot capture the cross and nonlinear relationships between features. The FM model introduces latent vectors to factorize features, effectively capturing second-order interactions between features. Compared to LR, FM has the following advantages:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Feature Interaction"}),": FM can automatically learn interactions between features without manually constructing cross-features, leading to better performance on complex datasets."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Model Flexibility"}),": FM performs well in highly sparse datasets and is suitable for scenarios with a large number of categorical features."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Strong Generalization"}),": By factorizing features, FM can avoid overfitting, especially when the data is high-dimensional but with a small sample size."]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"2-time-complexity-analysis-of-fm",children:"2. Time Complexity Analysis of FM"}),"\n",(0,a.jsx)(i.p,{children:"A significant advantage of the FM model is its efficient computational capability. Although FM considers interactions between all pairs of features, its time complexity remains\xa0($O(N)$)\xa0rather than\xa0($O(N\u200b^2\u200b\u200b)$). This is because FM simplifies the calculation of feature interactions through factorization as follows:"}),"\n",(0,a.jsx)(i.p,{children:"$\\hat{y}(x) = w_0 + \\sum_{i=1}^{N}w_ix_i + \\sum_{i=1}^{N}\\sum_{j=i+1}^{N} \\langle v_i, v_j \\rangle x_ix_j$"}),"\n",(0,a.jsx)(i.p,{children:"where\xa0(\u27e8v\u200bi\u200b\u200b,v\u200bj\u200b\u200b\u27e9)\xa0denotes the inner product of two feature latent vectors, significantly reducing computational cost. The steps are as follows:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Linear Term"}),":\xa0($\\sum_{i=1}^{N}w_ix_i$), with a time complexity of\xa0($O(N)$)."]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Interaction Term"}),": Through factorization,\xa0($\\sum_{i=1}^{N}\\sum_{j=i+1}^{N} \\langle v_i, v_j \\rangle x_ix_j$)\xa0can be computed in\xa0($O(N)$)\xa0time."]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"This efficiency allows FM to maintain fast computation speeds even when handling large-scale datasets."}),"\n",(0,a.jsx)(i.h3,{id:"3-ease-of-engineering-implementation",children:"3. Ease of Engineering Implementation"}),"\n",(0,a.jsx)(i.p,{children:"The FM model not only has theoretical advantages but is also relatively simple to implement in practice, especially when developed and deployed using deep learning frameworks like PyTorch. Below is a brief explanation and example code of implementing FM using PyTorch:"}),"\n",(0,a.jsx)(i.h3,{id:"developing-and-training-fm-model-with-pytorch",children:"Developing and Training FM Model with PyTorch"}),"\n",(0,a.jsx)(i.p,{children:"Developing an FM model with PyTorch is very straightforward, as PyTorch's flexibility and ease of use make customizing model structures and training processes simple. Here is a simplified implementation example of an FM model:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:"import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\nclass FactorizationMachine(nn.Module):\n    def __init__(self, n_features, k):\n        super(FactorizationMachine, self).__init__()\n        self.linear = nn.Linear(n_features, 1)\n        self.v = nn.Parameter(torch.randn(n_features, k))\n\n    def forward(self, x):\n        linear_part = self.linear(x)\n        interaction_part = 0.5 * torch.sum(\n            torch.pow(torch.mm(x, self.v), 2) - torch.mm(torch.pow(x, 2), torch.pow(self.v, 2)), dim=1, keepdim=True\n        )\n        return linear_part + interaction_part\n\n# Example usage\nn_features = 10  # Assuming 10 features\nk = 5  # Dimension of latent vectors\n\nmodel = FactorizationMachine(n_features, k)\ncriterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Assuming we have some training data\nX_train = torch.randn(100, n_features)  # 100 samples\ny_train = torch.randn(100, 1)\n\n# Training process\nmodel.train()\nfor epoch in range(100):  # Train for 100 epochs\n    optimizer.zero_grad()\n    outputs = model(X_train)\n    loss = criterion(outputs, y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (epoch+1) % 10 == 0:\n        print(f'Epoch [{epoch+1}/100], Loss: {loss.item():.4f}')\n"})}),"\n",(0,a.jsx)(i.p,{children:"Through the above code example, it is evident that implementing the FM model with PyTorch is intuitive and flexible. Users can easily adjust model structures, optimizers, and loss functions to quickly adapt to different business needs."}),"\n",(0,a.jsx)(i.h2,{id:"application",children:"Application"}),"\n",(0,a.jsx)(i.h3,{id:"1-feature-embedding-configuration",children:"1. Feature Embedding Configuration"}),"\n",(0,a.jsx)(i.p,{children:"In our FM model, the embedding dimension for each feature is set to 10. This configuration allows us to fully capture the interactions between features without adding excessive computational overhead. Choosing the right embedding dimension is a critical step in balancing model complexity and computational efficiency."}),"\n",(0,a.jsx)(i.h3,{id:"2-addressing-sample-imbalance-issues",children:"2. Addressing Sample Imbalance Issues"}),"\n",(0,a.jsx)(i.p,{children:"During the model training process, we found a significant imbalance in the ratio of positive to negative samples, primarily due to the substantial differences in homepage exposure click data. To address this issue, we conducted two experiments:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Random Negative Sample Dropping"}),": This straightforward method aims to balance the sample ratio by reducing the number of negative samples. However, our experiments showed that while this approach can somewhat alleviate the imbalance issue, it does not significantly improve model performance."]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Positive Sample Weighting"}),": In contrast, we applied weighting to positive samples, giving them higher learning importance. This method better emphasizes genuine user interest behaviors. By adjusting sample weights, we effectively increased the model's focus on positive samples, leading to a significant improvement in overall model performance."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"The experiments demonstrated that positive sample weighting outperforms random negative sample dropping. This is mainly because weighting allows us to more accurately capture user interest preferences, avoiding model bias caused by an excess of negative samples."}),"\n",(0,a.jsx)(i.h3,{id:"3-data-issues-and-model-optimization",children:"3. Data Issues and Model Optimization"}),"\n",(0,a.jsx)(i.p,{children:"During the initial model training, we encountered a critical issue: training with the full dataset did not achieve the expected results. Upon thorough investigation, we discovered that many homepage exposures used frontend caching due to network issues. These cached data were not user-initiated actions, thus interfering with the model's learning process."}),"\n",(0,a.jsx)(i.p,{children:"To resolve this issue, we differentiated the reported data on the first screen, removing the cached data. This approach ensured that the model was trained using genuine user behavior data, ultimately ensuring the effectiveness of the model once deployed."}),"\n",(0,a.jsx)(i.h3,{id:"4-ab-testing-results",children:"4. AB Testing Results"}),"\n",(0,a.jsxs)(i.p,{children:["The effect of online weighting was verified through AB testing. Specific AB test screenshots will be presented here, further proving the effectiveness of our optimization strategies in practical applications. In the ",(0,a.jsx)(i.strong,{children:"Guess You Like"})," section on the homepage, the average distribution per person increased by ",(0,a.jsx)(i.strong,{children:"14.8%"}),"."]}),"\n",(0,a.jsx)(i.img,{title:"",src:"../static/images/FM-AB.webp",alt:"",width:"522","data-align":"center"}),"\n",(0,a.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://github.com/rixwew/pytorch-fm",children:"Factorization Machine models in PyTorch - GitHub"})}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://d2l.ai/chapter_recommender-systems/fm.html",children:"Factorization Machines"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>o});var t=n(6540);const a={},s=t.createContext(a);function r(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);